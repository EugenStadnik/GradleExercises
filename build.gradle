import com.dev.task.ReleaseTask

import java.time.LocalDate
import org.apache.commons.lang3.StringUtils // define
// buildscript { dependencies { classpath "org.apache.commons:commons-lang3:3.12.0" } }
// before to use this library

// To configure properties of a *.gradle script will be applicable only during the gradle runtime
buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        // the *implementation* configurationName is not available here cause the *buildscript{}* DSL is a config phase
        classpath "org.apache.commons:commons-lang3:3.12.0" // Only after this particular library is applied you can
        // do *import org.apache.commons.lang3.StringUtils* inside a *.gradle script and
        // use the feature inside a *.gradle script. For ex.: investigate CAPITALIZED variable definition
    }

}

// STANDARD PLUGINS
// Also there are a lot of standard plugins like "java" available from the box. To apply it:
// apply plugin: "java" // Deprecated way to apply standard plugins
plugins { // Only after specific plugin is applied the gradle allows you to use most useful DSL entities
    id 'java'
    // To build project as *.war application apply the "war" plugin
    id 'war'
    // it will replace the "jar" task dependency in the "assemble" task
    // do not forget to include "jakarta.servlet" dependency, implement simple "Servlet" class and run Tomcat:10
    id 'jacoco'
    // The 'jacoco' plugin allows to analyze test coverage
    // setup jacocoTestReport and jacocoTestCoverageVerification tasks dependencies for they to be dependentOn 'test' task
    // and for they to finalizedBy 'test' task
    // for more details refer to https://docs.gradle.org/current/userguide/jacoco_plugin.html#header
    // Another one useful test and source code analyzer plugin is https://docs.gradle.org/current/userguide/checkstyle_plugin.html#header
    id 'custom-plugin-id' // <--------------------------------------------------------------------------------------|
} //                                                                                                                |
// Uncomfortable though possible way to apply plugin                                                                |
apply plugin: com.dev.plugin.CustomPlugin //                                                                        |
// better to assign specific id in ./buildSrc/src/main/resources/META-INF/gradle-plugin/id-value.properties file ---|

// To implement default behavior for current and all subprojects
allprojects {
    def CAPITALIZED = StringUtils.capitalize("value") // to do that first define
    // buildscript { dependencies { classpath "org.apache.commons:commons-lang3:3.12.0" } } then
    // import org.apache.commons.lang3.StringUtils in the beginning of *.gradle script
    group = "com.dev"
    description = "all projects description"
    repositories {
        mavenCentral()
    }
    // Strongly recommended to use for attributes and repositories determination only
}
// To implement default behavior for all subprojects of a current project only
subprojects {
    group = "com.dev"
    description = "all sub-projects description"
    repositories {
        mavenCentral()
    }
    // Strongly recommended to use for attributes and repositories determination only
}
// WORST WAY TO CONFIGURE OTHER MODULES FORM THE CURRENT ONE
project(":database") {
    group = "com.dev"
    description = ":database module description"
    repositories {
        mavenCentral()
    }
    // NEVER EVER DO THAT ... NEVER ... EVER
}

// Just to check *allprojects{}* and *subprojects{}* DSL behavior
println "The \"description\" variable value for ${project.name} project is: \"${description}\""

// To set java version for source and compiled classes
java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

group = 'com.dev'
version = '1.0'

// APPLY REPOSITORIES LIST IN A SPECIFIC ORDER
// gradle stores all downloaded or found dependencies in ~/.gradle/caches
// gradle will search for each dependency determined in a *dependencies {}* area starting from first determined repository
// and follow each next repository in order of their (repositories) determination.
// When specific dependency found gradle stops to search the dependency in other following repositories.
// When no dependency found in any specified repositories the build process will fail with appropriate error message.
repositories { // the implementation of org.gradle.api.artifacts.dsl.RepositoryHandler.repositories(Closure configureClosure) interface i.e. DefaultRepositoryHandler
    mavenCentral() // refers to String MAVEN_CENTRAL_URL = "https://repo.maven.apache.org/maven2/" in org.gradle.api.artifacts.ArtifactRepositoryContainer
    mavenLocal() // invoked as system.getProperty("maven.repo.local") in org.gradle.api.internal.artifacts.mvnsettings.DefaultLocalMavenRepositoryLocator
    // refers to ~/.m2/repository

    // To specify custom repository
    maven {
        name "project nexus"
        url "https://nexus.epam.com/repository"
    }
    // or even
    maven {
        name "spring"
        url "https://repo.spring.io/release"
    }

    // To specify local HDD dir repository // NOT RECOMMENDED - depends on yor local environment and high risk of failure against global build runner container
    flatDir {
        name "local dir"
        dir("~/RepoDir")
    }
    // or even can specify multiple
    flatDir {
        name "local dirs"
        dirs("~/RepoDir1", "~/RepoDir2")
    }

    // to search for dependencies already cached in ~/.gradle/caches and do not search for dependencies over the internet
    // just use *--offline* VM option with the *$ gradle* invocation. For ex.: *$ gradle --offline build*
    // WARNING when no dependency cached in the offline mode the build will fail
    // Whe IDEA "gradle" UI bookmark is used tap "-//-" - "Toggle Offline Mode" button to use gradle in the offline mode
}

// TO CREATE CUSTOM CONFIGURATIONS
configurations { // the org.gradle.api.internal.project.DefaultProject.configurations(Closure configureClosure) implementation
    // represents a org.gradle.api.internal.artifacts.configurations.DefaultConfigurationContainer
    Configuration implementationConfig = getByName("implementation")
    implementationConfig.getDependencies() // the org.gradle.api.artifacts.DependencySet will be retrieved
    //      and this Set contains "spring-webmvc" appended in *dependencies{}* area

    // The configuration{} section is just a container (DefaultConfigurationContainer)
    //      so any configuration created will only extend or contain any other default configuration(s)
    //      so to implement custom configuration
    myConfig {
        description = "my configuration"
    }
    implementationConfig.extendsFrom(myConfig)

    // TO ENFORCE SPECIFIC TRANSITIVE DEPENDENCY VERSION
    all {
        resolutionStrategy {
            force ("org.springframework:spring-beans:5.3.8")
        }
    }
}

// TO CONNECT THIRD PARTY LIBRARIES USE FOLLOWING SYNTAX
dependencies { // the org.gradle.api.internal.project.DefaultProject.dependencies(Closure configureClosure) implementation

    // To demo the "war" plugin advantages include "servlet"
    compileOnly "jakarta.servlet:jakarta.servlet-api:5.0.0"
    // do not forget to apply "war" plugin, implement simple "Servlet" class and run Tomcat:10

    add("implementation", [group: "org.springframework", name: "spring-webmvc", version: "5.3.9"])
    // the o.g.a.i.a.d.d.DefaultDependencyHandler.add(String configurationName, Object dependencyNotation) implementation
    // the "implementation" is a configuration name (should to be created already) (implemented in a org.gradle.api.plugins.JavaPlugin)
    // Most versions consist of major.minor.increment-qualifier
    // for "spring-webmvc" major=5, minor=3, increment=9, qualifier=SNAPSHOT
    // usually the SNAPSHOT is a non-production version

    // PLATFORM SUPPORT
    add("testImplementation", platform('org.junit:junit-bom:5.9.1')) // same as previous but a syntax sugar
    // The platform() is an org.gradle.api.internal.artifacts.dsl.dependencies.PlatformSupport implementation
    // The platform() is just a *.pom file where all dependencies and their conflicts already resolved successfully
    // The platform() as itself doesn't download any *.jar files or any other libraries
    // Investigate ~/.gradle/caches/modules-2/files-2.1/org.junit/junit-bom/5.9.1/ to ensure

    // When you have multiple dependency conflict resolve strategies like "configurations -> all -> resolutionStrategy -> force"
    // and you need the platform to resolve all conflicts by itself overriding all previous strategies
    // use enforcedPlatform() instead of regular platform()
    add("testImplementation", enforcedPlatform('org.junit:junit-bom:5.9.1')) // same as previous but a syntax sugar
    // To download related to platform library or *.jar file
    // specify needed group: and name: omitting the version: value as it is already resolved in platform
    testImplementation 'org.junit.jupiter:junit-jupiter' // same as previous but a syntax sugar
    // When no supported version found either from manual determination or from the platform *.pom file
    // the application won't build but fail with gradle errors

    // After *$ gradle build* triggered investigate
    // ~/.gradle/caches/modules-2/files-2.1/org.springframework/spring-webmvc/5.3.9/
    // ~/.gradle/caches/modules-2/files-2.1/org.junit/junit-bom/5.9.1/
    // ~/.gradle/caches/modules-2/files-2.1/org.junit.jupiter/junit-jupiter/5.9.1/
    // directories content

    // To investigate all available configurations and their dependencies observe
    // https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_plugin_and_dependency_management
    // *implementation* - Implementation only dependencies.
    // *compileOnly* - Compile time only dependencies, not used at runtime.
    //      Example: servlet API - already available in ApacheTomcat so is not needed for runtime
    // *compileClasspath* extends compileOnly, implementation.
    //      Compile classpath, used when compiling source. Used by task compileJava.
    //      Observe IDEA UI "gradle" bookmark's "Dependencies" -> "compileClasspath" tab.
    //      Is used by *compile* java task
    // *annotationProcessor* - Annotation processors used during compilation.
    //      Example: lombock annotation processor
    // *runtimeOnly* - Runtime only dependencies.
    //      Example: DB drivers
    // *runtimeClasspath* extends runtimeOnly, implementation.
    //      Runtime classpath contains elements of the implementation, as well as runtime only elements.
    //      Observe IDEA UI "gradle" bookmark's "Dependencies" -> "runtimeClasspath" tab.
    // *testImplementation* extends implementation. Implementation only dependencies for tests.
    // *testCompileOnly* - Additional dependencies only for compiling tests, not used at runtime.
    // *testCompileClasspath* extends testCompileOnly, testImplementation.
    //      Test compile classpath, used when compiling test sources. Used by task compileTestJava.
    //      Observe IDEA UI "gradle" bookmark's "Dependencies" -> "testCompileClasspath" tab.
    // *testRuntimeOnly* extends runtimeOnly. Runtime only dependencies for running tests.
    // *testRuntimeClasspath* extends testRuntimeOnly, testImplementation.
    //      Runtime classpath for running tests. Used by task test.
    //      Observe IDEA UI "gradle" bookmark's "Dependencies" -> "testRuntimeClasspath" tab.

    // So *compileJava*, *compileTestJava* and *test* tasks from *java* plugin depends on some of standard configurations
    //  _____________   ________________   _____________
    // | compileOnly | | implementation | | runtimeOnly |
    //  ¯¯¯¯¯¯¯¯¯¯¯¯¯   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯   ¯¯¯¯¯¯¯¯¯¯¯¯¯
    //        |           |        |            |
    //      __________________   __________________
    //     | compileClasspath | | runtimeClasspath |
    //      ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
    //              | uses
    //        _____________
    //       | compileJava | - implemented in a *java* gradle plugin
    //        ¯¯¯¯¯¯¯¯¯¯¯¯¯
    //
    //                        ________________     _____________
    //                       | implementation |   | runtimeOnly |
    //                        ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯     ¯¯¯¯¯¯¯¯¯¯¯¯¯
    //                               |                   |
    //  _________________   ____________________   _________________
    // | testCompileOnly | | testImplementation | | testRuntimeOnly |
    //  ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
    //            |           |              |            |
    //        ______________________     ______________________
    //       | testCompileClasspath |   | testRuntimeClasspath |
    //        ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯     ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
    //                | uses                       | uses
    //        _________________                  ______
    //       | compileTestJava |                | test | - implemented in a *java* gradle plugin
    //        ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯                  ¯¯¯¯¯¯
    //         |- implemented in a *java* gradle plugin

    // TO USE CUSTOM CONFIGURATION
    myConfig "org.projectlombok:lombok:1.18.24"
    // refer to *configurations{}* section determined earlier

    // TRANSITIVE DEPENDENCIES
    //      are the dependencies which unambiguously determined dependencies depend on
    //      Let's say user wants to include RestAssured
    implementation("io.rest-assured:rest-assured:5.3.1") {
        // the o.g.a.i.a.d.d.DefaultDependencyHandler.add(String configurationName, Object dependencyNotation, Closure closure) implementation

        // so when you'll investigate IDEA *gradle* bookmark's
        // testRuntimeClasspath -> io.rest-assured:rest-assured:5.3.1 tab
        // you'll see other dependencies appended ambiguously with major rest-assured library like
        // org.apache.groovy:groovy:4.0.11 -> org.apache.groovy:groovy-bom:4.0.11 -> org.apache.groovy:groovy-json:4.0.11
        // and so on
        // In addition when you'll investigate
        // ~/.gradle/caches/modules-2/files-2.1/io.rest-assured/rest-assured/5.3.1/9fbe3a3b214560053208f9950c3951f19f563373/rest-assured-5.3.1.pom
        // file you'll see it contains dependency to org.apache.groovy:groovy:4.0.11
        // when you'll investigate
        // ~/.gradle/caches/modules-2/files-2.1/org.apache.groovy/groovy/4.0.11/ecc87b64364dedd876c292c814a37ae0525d0fb1/groovy-4.0.11.pom
        // file you'll see it contains dependency to org.apache.groovy:groovy-bom:4.0.11
        // and so on
        // THESE ALL ARE TRANSITIVE DEPENDENCIES
        // AND CAN BE USED IN A SOURCE CODE AS WELL AS MAIN DEPENDENCY

        exclude(group: "io.rest-assured", module: "xml-path") // will exclude specific library
        // If you want to add the same library but of specific version just append related *implementation{}*
        // or *testImplementation{}* configuration to *dependencies{}* area
        // BUT keep in mind the closest to main dependency transitive dependency version will be included

        transitive(false) // to exclude ALL transitive dependencies
        // If you want to add the same library but of specific version just append related *implementation{}*
        // or *testImplementation{}* configuration to *dependencies{}* area
        // BUT keep in mind the closest to main dependency transitive dependency version will be included
    }
    implementation "org.springframework:spring-aop:5.3.8"
    // As you can see in the *Gradle* bookmark of IDEA UI
    // the org.springframework:spring-aop:5.3.9 (*) is forced to include
    // as it is transitive dependency and org.springframework:spring-webmvc:5.3.9 depends on it

    implementation("org.springframework:spring-beans:5.3.8") {
        // force(true)
        // will enforce the org.springframework:spring-beans:5.3.8 to include
        // another way better to use to force specific versions is to use configurations -> all -> resolutionStrategy -> force syntax
        // investigate *configurations{}* snippet
    }

    // ENTER "$ gradle dependencies" TO INVESTIGATE DEPENDENCIES GRAPH
}

test {
    // To run tests in parallel
    maxParallelForks 2

    // useTestNG() // To run TestNG tests. Apply TestNG dependencies and configure you tests as TestNG first
    useJUnitPlatform() // To run JUnit 5 tests. Apply JUnit dependencies and configure you tests as JUnit first
    // If no test platform determined the JUnit 4 will be applied by default
    // For more info refer to https://docs.gradle.org/current/dsl/org.gradle.api.tasks.testing.Test.html

    // To run only a specific project (module) tests type *$ gradle :module:subModule:test*
    // For ex.: gradle :service:test
}
// Before to setup 'jacoco' tasks dependencies import 'jacoco' plugin first
test.finalizedBy jacocoTestReport
jacocoTestReport.dependsOn test
// for more details refer to https://docs.gradle.org/current/userguide/jacoco_plugin.html#header
// Another one useful test and source code analyzer plugin is https://docs.gradle.org/current/userguide/checkstyle_plugin.html#header

println "config phase"
println "gradle hash: ${gradle.hashCode()}"
println "gradle root project hash: ${gradle.rootProject.hashCode()}"
println "root project hash: ${rootProject.hashCode()}"
println "project hash: ${project.hashCode()}"

// TASKS AND THEIR ATTRIBUTES DETERMINATION
// Task task = new DefaultTask() {};
task("hello")
tasks.findByName("hello").description = "Hello task"
// However more comfortable way is
hello.description = "Hello task"
hello.group = "dev"
// However more more comfortable way is
// public Task configure(Closure closure) of AbstractTask class
hello {
    println "conf phase. Task hello"
    description = "Hello task"
    group = "hello"
}

// However more more more more comfortable way is

task("hello2", {
    println "conf phase. Task hello2"
    description = "Hello2 task"
    group = "hello"
})

// However more more more more more comfortable way is

task("hello3") {
    println "conf phase. Task hello3"
    description = "Hello3 task"
    group = "hello"
}

// However more more more more more more comfortable way is

task "hello4" {
    println "conf phase. Task hello4"
    description = "Hello4 task"
    group = "hello"
}

// However more more more more more more more comfortable way is

task hello5 {
    println "conf phase. Task hello5"
    description = "Hello5 task"
    group = "hello"
}

// another one syntax sugar way is to use java.util.Map with Closure

def map = [description: "Hello6 task", group: "hello"]
task (map, "hello6") {
    println "conf phase. Task hello6"
    println "description: \"${description}\", group: \"${group}\", actions: \"${actions}\""
}

// At last the best of the best way to init task is

task hello7(description: "Hello7 task", group: "hello", type: DefaultTask.class) {
// When you'll not specify the type - it's ok. yor currently created task will be extended from DefaultTask.class by default
// However you can extend your task from any of org.gradle.api.Task subclasses
    println "conf phase. Task hello7"
    println "description: \"${description}\", group: \"${group}\", actions: \"${actions}\""
}

task hello8(description: "Hello8 task", group: "hello", type: DefaultTask) {
// When you'll not specify the type - it's ok. yor currently created task will be extended from DefaultTask.class by default
// However you can extend your task from any of org.gradle.api.Task subclasses
    println "conf phase. Task hello8" // Will be triggered on config phase only
    println "description: \"${description}\", group: \"${group}\", actions: \"${actions}\"" // Will be triggered on config phase only
    doLast { // this is the org.gradle.api.Action will be appended to the end of the "actions" List in order to determination
        println "execution phase, Action 1" // Will be triggered on exec phase only
    }
    doFirst { // this is the org.gradle.api.Action will be appended to the beginning of the "actions" List in order to determination
        println "execution phase, Action 2" // Will be triggered on exec phase only
    }
    doLast { // this is the org.gradle.api.Action will be appended to the end of the "actions" List in order to determination
        println "execution phase, Action 3" // Will be triggered on exec phase only
    }
    doFirst { // this is the org.gradle.api.Action will be appended to the beginning of the "actions" List in order to determination
        println "execution phase, Action 4" // Will be triggered on exec phase only
    }
    println "description: \"${description}\", group: \"${group}\", actions: \"${actions}\"" // Will be triggered on config phase only
    println "path task: ${path}" // Will be triggered on config phase only
    //gradle.taskGraph.allTasks
}

hello8.doFirst { // one of the variances to determine the org.gradle.api.Action
    println "execution phase, Action 5"
}

// TASK DEPENDENCY DETERMINATION
task first {
    onlyIf {return true} // The task will be triggered only if Closure returns true depending on condition determined in the Closure
    doLast {
        println "Task first"
    }
}
task second {
    onlyIf {return true} // The task will be triggered only if Closure returns true depending on condition determined in the Closure
    doLast {
        println "Task second"
    }
}
task third {
    onlyIf {return true} // The task will be triggered only if Closure returns true depending on condition determined in the Closure
    doLast {
        println "Task third"
    }
}
// To determine task 4 dependent on task 2
task fourth/*(dependsOn: second) or even (dependsOn: [first, second]) also applicable*/ {
    onlyIf {return true} // The task will be triggered only if Closure returns true depending on condition determined in the Closure
    //dependsOn first
    //dependsOn(second, third)
    doLast {
        println "Task fourth"
    }
}
fourth.dependsOn second
//fourth.dependsOn(second, third) // As a variant
// To determine task 1 dependent on task 2
second.finalizedBy third // The reverse dependency determination comparing to *dependsOn*
// can be used as task parameter like *task second(finalizedBy first)*
// or even determined in a closure like *{ //finalizedBy(second, third) }*

// DETERMINE ORDER WITHOUT DEPENDENCY
// Let's say I need
// 2 <-\
// 1 <--- 4
// 3 <-/
// Commonly the 1,2,3 tasks order is not guaranteed. However usually 1,2,3 tasks executed in order of their determination
// BUT I NEED 4-th task depends on all 1, 2, 3 tasks and 1 must run after 2 without a dependency
task one {
    onlyIf {return true} // The task will be triggered only if Closure returns true depending on condition determined in the Closure
    doLast {
        println "Task one"
    }
}
task two {
    onlyIf {return true} // The task will be triggered only if Closure returns true depending on condition determined in the Closure
    doLast {
        println "Task two"
    }
}
task three {
    onlyIf {return true} // The task will be triggered only if Closure returns true depending on condition determined in the Closure
    doLast {
        println "Task three"
    }
}
task four(dependsOn: one, group: "MyGroup") {
    onlyIf {return true} // The task will be triggered only if Closure returns true depending on condition determined in the Closure
    dependsOn two
    doLast {
        println "Task four"
    }
}
four.dependsOn three
one.mustRunAfter two
//one.shouldRunAfter two // Also a valid syntax

// TASK GRAPH CALL-BACK
// To investigate task graph use *Task Graph CallBacks*
gradle.taskGraph.whenReady { TaskExecutionGraph graph ->
    println "---- Graph:"
    graph.allTasks.each {Task task ->
        println "${task.name}"
    }
    println "!!! CONCLUSION - the graph is initialized depending on task invoked"
}
//gradle.taskGraph.allTasks.each {} // Will throw exception as build.gradle id a config phase
// so the task graph will be completely initialized only in the finish of config phase
gradle.taskGraph.beforeTask { Task task -> // Will be triggered before each task if other condition is not determined
    if (task.getGroup() == "MyGroup") { // will be triggered only if task is assigned to "MyGroup" group
        // don't forget to assign the task to a group
        println "${task} beforeTask callback"
    }

}
gradle.taskGraph.afterTask { Task task -> // Will be triggered after each task if other condition is not determined
    if (task.getName() == "two") { // will be triggered only if task is of "two" name
        println "${task} afterTask callback"
    }
}
// When no other task is triggered during *$ gradle* invocation the *help* task will be triggered by default
// To override such a behavior append all tasks should be triggered by default at the list of default tasks
defaultTasks "first", "one"

// PROPERTIES INTERACTION
// to set properties inside gradle script use *ext*
ext {
    javaVersion = "17"
    currentDate = LocalDate.now()
}
// to invoke properties use
println project.ext.javaVersion // or
println ext.javaVersion // or
println project.javaVersion // or
println javaVersion
// another way to determine properties using gradle is to create ///MyProject/gradle.properties file
// but determine only gradle related properties in it.
// The determination of *spring_version* properties in a ///MyProject/gradle.properties file is a bad practice
// The recommended gradle properties - https://docs.gradle.org/current/userguide/build_environment.html#header
println "---- All project properties:"
println project.properties
println "---- System \"sys.example\" property:"
println System.getProperty("sys.example") // Do not forget to specify -Dsys.example=sysValue as CMD argument during *$ gradle* invocation
println "---- Project \"proj.param\" property:"
println project.getProperties().get("proj.param") // Do not forget to specify -Pproj.param=projValue as CMD argument during *$ gradle* invocation

// CUSTOM PLUGINS
// NOT THE BEST WAY TO CREATE PLUGINS. Better create groovy class in the buildSrc folder
// 1. Script Plugin: create ///MyProject/name.gradle file and describe there part of a gradle script
// then apply the part in the main build.gradle specifying path to the name.gradle file
apply from: "./name.gradle"
// 2. plugin class creation
class CustomPlugin implements Plugin<Project> {
    @Override
    void apply(Project target) {
        classPluginTask(target);
    }

    void classPluginTask(Project target) {
        def map = [description: "classPluginTask task", group: "customPlugins", type: DefaultTask]
        target.task(map, "classPluginTask") {
            // When you'll not specify the type - it's ok. yor currently created task will be extended from DefaultTask.class by default
            // However you can extend your task from any of org.gradle.api.Task subclasses
            println "conf phase. Task classPluginTask" // Will be triggered on config phase only
            println "description: \"${description}\", group: \"${group}\", actions: \"${actions}\"" // Will be triggered on config phase only
            doLast { // this is the org.gradle.api.Action will be appended to the end of the "actions" List in order to determination
                println "execution phase, Action 1" // Will be triggered on exec phase only
            }
            doFirst { // this is the org.gradle.api.Action will be appended to the beginning of the "actions" List in order to determination
                println "execution phase, Action 2" // Will be triggered on exec phase only
            }
            doLast { // this is the org.gradle.api.Action will be appended to the end of the "actions" List in order to determination
                println "execution phase, Action 3" // Will be triggered on exec phase only
            }
            doFirst { // this is the org.gradle.api.Action will be appended to the beginning of the "actions" List in order to determination
                println "execution phase, Action 4" // Will be triggered on exec phase only
            }
            println "description: \"${description}\", group: \"${group}\", actions: \"${actions}\"" // Will be triggered on config phase only
            println "path task: ${path}" // Will be triggered on config phase only
            //gradle.taskGraph.allTasks
        }
    }
}
// Then apply class plugin
apply plugin: CustomPlugin
// apply plugin: CustomPlugin.class // is also a valid syntax
// ADVANTAGE - as ClassPlugin is a class it can be implemented and covered by tests more flexible
// DISADVANTAGE - ClassPlugin is bulky and need to be switched outside the build.gradle script into /buildSrc directory

// ADDITIONAL SOURCES
// Whe additional data classes are generated and placed to a specific directory before build developer should to append that additional sources to a project
sourceSets {
    main {
        java {
            // srcDir = ['src/java'] // will REDEFINE resource URI // DO NOT DO LIKE THAT
            srcDir("src/commonDataClasses/java") // will append ///MyProject/src/dataClasses/java to build
            srcDirs("src/inputDataClasses/java", "src/outputDataClasses/java")
            // will append ///MyProject/src/inputDataClasses/java and ///MyProject/src/outputDataClasses/java to build
        }
        resources {
            // srcDir = ['src/resources'] // will REDEFINE resource URI // DO NOT DO LIKE THAT
            srcDir("src/commonDataClasses/resources") // will append ///MyProject/src/dataClasses/resources to build
            srcDirs("src/inputDataClasses/resources", "src/outputDataClasses/resources")
            // will append ///MyProject/src/inputDataClasses/resources and ///MyProject/src/outputDataClasses/resources to build
        }
    }
    /*test {

    }*/
}

println "\"hello\" task description: \"${hello.description}\""
println "\"hello\" task group: \"${hello.group}\""

// FAT JAR - less prioritized way
// where all dependencies will be appended as unzipped or un-jar-ed *.class files to our *.jar application
task fatJar(type: Jar) {
    description = "Build jar including all dependent unarchived *.class files"
    group = "build"
    // the *jar{}* is just a org.gradle.api.tasks.bundling.Jar.jar(Closure closure) method implementation as TASK available in a *java* plugin
    // When *$ gradle assemble* or *$ gradle jar* task is invoked with default or empty *jar{}* task implementation
    // the jar/META_INF/MANIFEST.MF file will not contains the main class reference and *$ java -jar myApp.jar* invocation
    // will fail with "no main manifest attribute" error.
    // To fix it either append "Main-Class: com.dev.HelloWorld" or better to determine
    manifest {
        attributes "Main-Class": "com.dev.HelloWorld"
    }
    // Regardless *manifest {}* is determined the *$ gradle assemble* or *$ gradle jar*
    // task invocation still will fail with *java.lang.NoClassDefFoundError*
    // as no related dependency classes appended to our *.jar
    // to fix it define
    from(configurations.runtimeClasspath.files.collect{ File file -> project.zipTree(file)})
    // Do not forget to unzip *.jar files retrieved by configurations.runtimeClasspath.files
    // as *.jar files libraries just appended to our project are not useful but *.class files are

    // Regardless all dependency *.class files are appended
    // each library contains it's own license.txt file such can be duplicated
    // to fix it define
    duplicatesStrategy(DuplicatesStrategy.EXCLUDE)
}

// FLAT JAR - more prioritized way
// where all dependencies *.jar files will be placed into a separate ./build/lib folder and determine relation in MANIFEST file
task copyAllDependencies(type: Copy) {
    from(configurations.runtimeClasspath.files)
    into("$buildDir/libs/lib")
}
jar.dependsOn(copyAllDependencies)
jar {
    // the *jar{}* is just a org.gradle.api.tasks.bundling.Jar.jar(Closure closure) method implementation as TASK available in a *java* plugin
    // When *$ gradle assemble* or *$ gradle jar* task is invoked with default or empty *jar{}* task implementation
    // the jar/META_INF/MANIFEST.MF file will not contains the main class reference and *$ java -jar myApp.jar* invocation
    // will fail with "no main manifest attribute" error.
    // To fix it either append "Main-Class: com.dev.HelloWorld" or better to determine
    manifest {
        attributes "Main-Class": "com.dev.HelloWorld",
        // Regardless *manifest {}* is determined the *$ gradle assemble* or *$ gradle jar*
        // task invocation still will fail with *java.lang.NoClassDefFoundError*
        // as no related dependency libraries appended to our *.jar application
        // to fix it define
        "Class-Path": configurations.runtimeClasspath.files.collect{File file -> "lib/$file.name"}.join(" ")
    }
}

ext {
    release = false
}

// TASKS CACHES
task makeRelease {
    // The cache is calculated relying on inputs and outputs
    // when the inputs and outputs doesn't change so the cache is also doesn't change
    // and task rerun is not needed as the predicted task result won't change as well
    inputs.property("release", project.release)
    outputs.file("$rootDir/script.gradle")
    doLast {
        println "release in progress..."
    }
}
// It is strongly recommended to shift complex logic outside the build.gradle script.
// Please refer to $rootDir/buildSrc/src/main/groovy/com/dev/task/ReleaseTask
task makeBuildSrcRelease(type: ReleaseTask) {
    release = project.release
    releaseFile = new File("$rootDir/script.gradle")
}